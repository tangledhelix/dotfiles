# PERL script to extract EXIF information from JPEGs generated by Canon
# digital cameras.
# This software is free and you may do anything like with it except sell it.
#
# Current version: 1.3
# Author: Chris Breeze
# email: chris@breezesys.com
# Web: http://www.breezesys.com
#
# Based on experimenting with my G1 and information from:
# http://www.butaman.ne.jp/~tsuruzoh/Computer/Digicams/exif-e.html
#
# Also Canon MakerNote from David Burren's page:
# http://www.burren.cx/david/canon.html
#
# Warnings: 
# 1) The Subject distance requires callibrating. The value in the
# EXIF data doesn't appear to follow the standard.
#
# Perl for Windows is available for free from:
# http://www.activestate.com
#
# History
# 11 Jan 2001
# v0.1: Initial version
#
# 14 Jan 2001
# v0.2: Updated with data from David Burren's page
#
# 15 Jan 2001
# v0.3: Added more info for D30 (supplied by David Burren)
# 1) D30 stores ISO in EXIF tag 0x8827, G1 uses MakerNote 0x1/16
# 2) MakerNote 0x1/10, ImageSize appears to be large, medium, small
# 3) D30 allows 1/2 or 1/3 stop exposure compensation
# 4) Added D30 custom function details, but can't test them
#
# 17 Jan 2001
# v1.0 Tidied up AutoFocusMode for G1 vs D30 + added manual auto focus point (D30)
#
# 18 Jan 2001
# v1.1 Removed some debug code left in by mistake
#
# 29 Jan 2001
# v1.2 Added flash mode (MakerNote Tag 1, field 4)
#
# 7 Mar 2001
# v1.3 Added ImageQuality (MakerNote Tag 1, field 3)
#
# 21 Apr 2001
# v1.4 added ImageStabilisation for Pro90 IS

my $debug = 0;					# output debug info
my $outputMakerNoteDebug = 0;	# output debug info about MakerNote IFD
my $outputUseful = 1;			# Only output 'useful' fields

my $intelAlignment = 0;			# byte alignment - read from EXIF header

my $cameraModel;

open(IN, $ARGV[0]) || die "Can't read file: $ARGV[0]";
binmode IN;	# Tell Windoze that we're reading a binary file

my %jpeg_markers = (
	SOF0	=> chr(0xc0),	#
	DHT		=> chr(0xc4),	# Define Huffman table
	SOI		=> chr(0xd8),	# Start of image
	EOI		=> chr(0xd9),	# End of image
	SOS		=> chr(0xda),	#
	DQT		=> chr(0xdb),	# Define quantisation table
	DRI		=> chr(0xdd),	# Define quantisation table
	APP1	=> chr(0xe1),	# APP1 - where EXIF data is stored
);

while (!eof(IN))
{
	# JPEG file is made up of blocks which start with a
	# 2 byte marker: 0xff, marker
	my $ch;
	die "End of file reached" if !read(IN, $ch, 1);

	# image data doesn't start with 0xff
	last if (ord($ch) != 0xff);  # skip the image data

	my $marker;
	die "End of file reached" if !read(IN, $marker, 1);

	if ($marker eq $jpeg_markers{SOI})
	{
		debug("SOI");
	}
	elsif ($marker eq $jpeg_markers{EOI})
	{
		debug("EOI");
	}
	else
	{
		my ($msb, $lsb, $data, $size);

		# Markers other than SOI and EOI have associated data
		# next 2 bytes are the length of this block (including themselves)
		die "Error reading length" if !read(IN, $msb, 1);
		die "Error reading length" if !read(IN, $lsb, 1);
		$size = 256 * ord($msb) + ord($lsb);

		# remainder of the block is size - 2 bytes long
		#my $data;
		die "File truncated" if read(IN, $data, $size - 2) != $size - 2;
			
		if ($marker eq $jpeg_markers{APP1})
		{
			# APP1 block contains the EXIF data
			debug("APP1\tlength: $size");
			exif($data);
		}
		elsif ($marker eq $jpeg_markers{DQT})
		{
			debug("DQT\tlength: $size");
		}
		elsif ($marker eq $jpeg_markers{SOF0})
		{
			debug("SOF0\tlength: $size");
		}
		elsif ($marker eq $jpeg_markers{DHT})
		{
				debug("DHT\tlength: $size");
		}
		elsif ($marker eq $jpeg_markers{SOS})
		{
			debug("SOS\tlength: $size");
		}
		else
		{
			printf("Unknown marker: 0x%04x, size: $size\n", $marker);
		}
	}
}
close IN;

# Extract EXIF data from the APP1 block
sub exif
{
	my ($data) = @_;

	# first 6 bytes should be the EXIF header: 'Exif\0\0'
	my $header = substr($data, 0, 6);
	die "APP1 does not contain EXIF data\n" if ($header ne "Exif\0\0");
	debug("Reading EXIF data");
	$data = substr($data, 6);

	# check TIFF header: Byte align/TAG/Offset to first IFD
	if (substr($data, 0, 2) eq 'II')
	{
		debug("Intel byte alignment");
		$intelAlignment = 1;
	}
	elsif (substr($data, 0, 2) eq 'MM')
	{
		debug("Motorola byte alignment");
		$intelAlignment = 0;
	}
	else
	{
		die "Invalid byte alignment";
	}

	# check EXIF tag (0x002a)
	debug ("Invalid tag mark") if readShort($data, 2) != 0x002a;

	# read offset to first IFD
	my $offset = readLong($data, 4);
	debug("Offset to first IFD: $offset");

	# first 2 bytes of IFD define the number of 12-byte entries
	my $numEntries = readShort($data, $offset);
	$offset += 2;
	debug("Number of directory entries: $numEntries");

	my $i;
	for ($i = 0; $i < $numEntries; $i++)
	{
		# Each entry is made up of 12 bytes
		# Tag (2 bytes)
		# Format (2 bytes)
		# Num components (4 bytes)
		# Data or offset to data if longer than 4 bytes (4 bytes)
		my $entry = substr($data, $offset + 12 * $i, 12);
		my $tag = readShort($entry, 0);
		my $format = readShort($entry, 2);
		my $components = readLong($entry, 4);
		my $offset = readLong($entry, 8);

		# Read the value using the appropriate format
		my $value =	readIFDEntry($data, $format, $components, $offset);

		# Decode individual EXIF tags
		if ($tag == 0x010e)
		{
			print "ImageDescription:\t$value\n" if !$outputUseful;
		}
		elsif ($tag == 0x010f)
		{
			print "Make:\t$value\n" if !$outputUseful;
		}
		elsif ($tag == 0x0110)
		{
			print "Model:\t$value\n";
			$cameraModel = $value;
		}
		elsif ($tag == 0x0112)
		{
			print "Orientation:\t$value\n" if !$outputUseful;
		}
		elsif ($tag == 0x011a)
		{
			print "XResolution:\t$value\n" if !$outputUseful;
		}
		elsif ($tag == 0x011b)
		{
			print "YResolution:\t$value\n" if !$outputUseful;
		}
		elsif ($tag == 0x0128)
		{
			print "ResolutionUnit:\t" if !$outputUseful;
			if ($value == 2)
			{
				print "inch\n" if !$outputUseful;
			}
			elsif ($value == 3)
			{
				print "centimetre\n" if !$outputUseful;
			}
			else
			{
				print "none\n" if !$outputUseful;
			}
		}
		elsif ($tag == 0x0131)
		{
			print "Software:\t$value\n" if !$outputUseful;
		}
		elsif ($tag == 0x0132)
		{
			print "DateTime:\t$value\n";
		}
		elsif ($tag == 0x0213)
		{
			print "YCbCrPositioning:\t" if !$outputUseful;
			if ($value == 1)
			{
				print "centre of pixel array\n" if !$outputUseful;
			}
			elsif ($value == 2)
			{
				print "datum point\n" if !$outputUseful;
			}
			else
			{
				print "undefined\n" if !$outputUseful;
			}
		}
		elsif ($tag == 0x8769)
		{
			# EXIF sub IFD - more detailed info
			exifSubIFD($data, $offset);
		}
		else
		{
			printf("Unrecognised entry: TAG=0x%x, $value\n", $tag);
		}
	}
	$offset = readLong($data, $offset + 12 * $numEntries);
	debug("Offset to next IFD: $offset");
}


# Extract EXIF sub IFD info
sub exifSubIFD
{
	my ($data, $offset) = @_;
	debug("EXIF: offset=$offset");

	# IFD starts with the number of entries
	my $numEntries = readShort($data, $offset);
	$offset += 2;
	debug("Number of directory entries: $numEntries");

	# Read the 12-byte long entries
	my $i;
	for ($i = 0; $i < $numEntries; $i++)
	{
		my $entry = substr($data, $offset + 12 * $i, 12);
		my $tag = readShort($entry, 0);
		my $format = readShort($entry, 2);
		my $components = readLong($entry, 4);
		my $offset = readLong($entry, 8);

		if ($tag == 0x9000)
		{
			print "ExifVersion:\t", substr($entry, 8, 4), "\n" if !$outputUseful;
		}
		elsif ($tag == 0x9101)
		{
			printf("ComponentsConfigured:\t0x%08x\n", $offset) if !$outputUseful;
		}
		elsif ($tag == 0x927c)
		{
			# Maker note contains manufacturer-specific data
			makerNote($data, $offset);
		}
		elsif ($tag == 0x9286)
		{
			# tag is present but doesn't seem to contain anything
			#print "UserComment:\t$offset\n";
			#print substr($data, $offset, 8), "\n";
		}
		elsif ($tag == 0xa000)
		{
			print "FlashPixVersion:\t$offset\n" if !$outputUseful;
		}
		elsif ($tag == 0xa300)
		{
			# 3 means digital still camera
			print "FileSource:\t$offset\n" if !$outputUseful;
		}
		else
		{
			my $value =	readIFDEntry($data, $format, $components, $offset);
			if ($tag == 0x829a)
			{
				if ($value >= 0.3)
				{
					print "ExposureTime:\t$value secs\n";
				}
				else
				{
					print "ExposureTime:\t1/", 1/$value, " sec\n";
				}
			}
			elsif ($tag == 0x829d)
			{
				print "FNumber:\t$value\n";
			}
			elsif ($tag == 0x8827)
			{
				# D30 stores ISO here, G1 uses MakerNote Tag 1, field 16
				print "ISOSpeedRatings:\t$value\n";
			}
			elsif ($tag == 0x9003)
			{
				print "DateTimeOriginal:\t$value\n" if !$outputUseful;
			}
			elsif ($tag == 0x9004)
			{
				print "DateTimeDigitized:\t$value\n" if !$outputUseful;
			}
			elsif ($tag == 0x9102)
			{
				# 5=superfine, 3=fine, 2=normal
				if ($value == 5)
				{
					print "ImageQuality:\tsuper fine\n";
				}
				elsif ($value == 3)
				{
					print "ImageQuality:\tfine\n";
				}
				elsif ($value == 2)
				{
					print "ImageQuality:\tnormal\n";
				}
				else
				{
					print "CompressedBitsPerPixel:\t$value\n";
				}
			}
			elsif ($tag == 0x9201)
			{
				# Not very accurate, use Exposure time instead
				$value = 2 ** $value;
				if ($value < 4)
				{
					$value = 1/$value;
					$value = (int($value * 10 + 0.5)) / 10;
					print "ShutterSpeedValue:\t$value secs\n" if !$outputUseful;
				}
				else
				{
					$value = int($value + 0.49);
					print "ShutterSpeedValue:\t1/$value sec\n" if !$outputUseful;
				}
			}
			elsif ($tag == 0x9202)
			{
				$value = int((sqrt(2) ** $value) * 10 + 0.5) / 10;
				print "ApertureValue:\t$value\n" if !$outputUseful;
			}
			elsif ($tag == 0x9204)
			{
				$value = compensationFraction($value);
				print "ExposureBiasValue:\t$value\n";
			}
			elsif ($tag == 0x9205)
			{
				$value = int((sqrt(2) ** $value) * 10 + 0.5) / 10;
				print "MaxApertureValue:\t$value\n";
			}
			elsif ($tag == 0x9206)
			{
				# Values look a bit suspect!
				# This needs callibrating. Multiplying by 2 looks more accurate for G1
				print "SubjectDistance:\t$value m\n";
			}
			elsif ($tag == 0x9207)
			{
				print "MeteringMode:\t";
				if ($value == 0)
				{
					print "unknown\n"
				}
				elsif ($value == 1)
				{
					print "average\n"
				}
				elsif ($value == 2)
				{
					print "centre weighted average\n"
				}
				elsif ($value == 3)
				{
					print "spot\n"
				}
				elsif ($value == 4)
				{
					print "multi-spot\n"
				}
				elsif ($value == 5)
				{
					print "multi-segment\n"
				}
				elsif ($value == 6)
				{
					print "partial\n"
				}
				else
				{
					print "other\n"
				}
			}
			elsif ($tag == 0x9209)
			{
				print "Flash:\t" if !$outputUseful;
				if ($value == 0)
				{
					print "no\n" if !$outputUseful;
				}
				elsif ($value == 1)
				{
					print "yes\n" if !$outputUseful;
				}
				else
				{
					print "unknown value: $value\n" if !$outputUseful;
				}
			}
			elsif ($tag == 0x920a)
			{
				print "FocalLength:\t$value mm\n";
			}
			elsif ($tag == 0xa001)
			{
				print "ColorSpace:\t$value\n" if !$outputUseful;
			}
			elsif ($tag == 0xa002)
			{
				print "ExifImageWidth:\t$value\n";
			}
			elsif ($tag == 0xa003)
			{
				print "ExifImageHeight:\t$value\n";
			}
			elsif ($tag == 0xa005)
			{
				print "ExifInteroperabilityOffset:\t$value\n" if !$outputUseful;
			}
			elsif ($tag == 0xa20e)
			{
				print "FocalPlaneXResolution:\t$value\n" if !$outputUseful;
			}
			elsif ($tag == 0xa20f)
			{
				print "FocalPlaneYResolution:\t$value\n" if !$outputUseful;
			}
			elsif ($tag == 0xa210)
			{
				print "FocalPlaneResolutionUnit:\t" if !$outputUseful;
				if ($value == 2)
				{
					print "inch\n" if !$outputUseful;
				}
				elsif ($value == 3)
				{
					print "centimetre\n" if !$outputUseful;
				}
				else
				{
					print "none\n" if !$outputUseful;
				}
			}
			elsif ($tag == 0xa217)
			{
				# 2 = 1 chip colour area sensor
				print "SensingMethod:\t$value\n" if !$outputUseful;
			}
			else
			{
				printf("Unrecognised EXIF TAG: 0x%x\n", $tag);
				die;
			}
		}
	}
}

# MakerNote: Canon proprietary data
sub makerNote
{
	my ($data, $offset) = @_;
	debug("MakerNote: offset=$offset");

	# It appears to be in IFD format
	my $numEntries = readShort($data, $offset);
	$offset += 2;
	debug("Number of directory entries: $numEntries");

	my $i;
	for ($i = 0; $i < $numEntries; $i++)
	{
		my $entry = substr($data, $offset + 12 * $i, 12);
		my $tag = readShort($entry, 0);
		my $format = readShort($entry, 2);
		my $components = readLong($entry, 4);
		my $offset = readLong($entry, 8);
		debug("$i)\tTag: $tag, format: $format, components: $components");
		if ($tag == 6)
		{
			my $value = readIFDEntry($data, $format, $components, $offset);
			print "ImageFormat:\t$value\n" if !$outputUseful;
		}
		elsif ($tag == 7)
		{
			my $value = readIFDEntry($data, $format, $components, $offset);
			print "FirmwareVersion:\t$value\n";
		}
		elsif ($tag == 8)
		{
			substr($offset, 3, 0) = '-';
			print "ImageNumber:\t$offset\n";
		}
		elsif ($tag == 9)
		{
			my $value = readIFDEntry($data, $format, $components, $offset);
			print "Owner:\t$value\n";
		}
		elsif ($tag == 0xc)
		{
			# Camera serial number
			my $msw = ($offset >> 16) & 0xffff;	
			my $lsw = $offset & 0xffff;	
			printf("CameraSerialNumber:\t%04X%05d\n", $msw, $lsw);
		}
		elsif ($tag == 0x10)
		{
			# I don't what these contain
			debug("MakerNote: tag $tag - skip for now");
		}
		else
		{
			# Several entries contain arrays of shorts
			if ($format == 3 && $components > 1)
			{
				print "MakerNote $i: TAG=$tag: " if $outputMakerNoteDebug;
				my $i;
				my @values;
				for ($i = 0; $i < $components; $i++)
				{
					$values[$i] = readShort($data, $offset + 2 * $i);
					print "$values[$i] " if $outputMakerNoteDebug;
				}
				print "\n" if $outputMakerNoteDebug;

				if ($tag == 1)
				{
					# field 0: length of tag in bytes

					# field 1: macro mode: 1 = macro, 2=normal
					if ($cameraModel !~ /Pro90/i)
					{
						# No macro mode for Pro90
						if ($values[1] == 1)
						{
							print "MacroMode:\tmacro\n";
						}
						else
						{
							print "MacroMode:\tnormal\n";
						}
					}

					# field 2: self-timer delay in 1/10 sec
					if ($values[2] > 0)
					{
						print "SelfTimer:\t", $values[2] / 10, " secs\n";
					}

					# field 3: image quality
					if ($values[3] == 2)
					{
						print "ImageQuality:\tNormal\n";
					}
					elsif ($values[3] == 3)
					{
						print "ImageQuality:\tFine\n";
					}
					elsif ($values[3] == 4)
					{
						print "ImageQuality:\tCCD Raw\n";
					}
					elsif ($values[3] == 5)
					{
						print "ImageQuality:\tSuper fine\n";
					}

					# field 4: flash mode
					if ($values[4] == 0)
					{
						print "Flash:\toff\n";
					}
					elsif ($values[4] == 1)
					{
						print "Flash:\tauto\n";
					}
					elsif ($values[4] == 2)
					{
						print "Flash:\ton\n";
					}
					elsif ($values[4] == 3)
					{
						print "Flash:\tred eye reduction\n";
					}
					elsif ($values[4] == 4)
					{
						print "Flash:\tslow synchro\n";
					}
					elsif ($values[4] == 5)
					{
						print "Flash:\tauto + red eye reduction\n";
					}
					elsif ($values[4] == 6)
					{
						print "Flash:\ton + red eye reduction\n";
					}

					# field 5: shooting mode
					if ($values[5])
					{
						print "ShootingMode:\tContinuous shooting\n";
					}
					else
					{
						print "ShootingMode:\tSingle frame shooting\n";
					}

					# field 6: unknown

					# field 7: Auto focus mode
					if ($values[7] == 0)
					{
						print "AutoFocusMode:\tone-shot\n";
					}
					elsif ($values[7] == 1)
					{
						print "AutoFocusMode:\tAI servo\n";
					}
					elsif ($values[7] == 2)
					{
						print "AutoFocusMode:\tAI focus\n";
					}
					elsif ($values[7] == 3 || $values[7] == 6)
					{
						print "AutoFocusMode:\tMF\n";
					}
					elsif ($values[7] == 4)
					{
						# G1: uses field 32 to store single/continuous
						# (and field 7 is always 4 on G1)
						if ($#values >= 32 && $values[32])
						{
							print "AutoFocusMode:\tcontinuous\n";
						}
						else
						{
							print "AutoFocusMode:\tsingle\n";
						}
					}
					elsif ($values[7] == 5)
					{
						print "AutoFocusMode:\tcontinuous\n";
					}

					# fields 8, 9: unknown

					# 10th field is image size
					if ($values[10] == 0)
					{
						print "ImageSize:\tlarge\n";
					}
					elsif ($values[10] == 1)
					{
						print "ImageSize:\tmedium\n";
					}
					elsif ($values[10] == 2)
					{
						print "ImageSize:\tsmall\n";
					}

					# field 11: 'Easy Shooting' mode - see field 20

					# field 12: unknown

					# Field 13: contrast
					if ($values[13] == 0)
					{
						print "Contrast:\tNormal\n";
					}
					elsif ($values[13] == 1)
					{
						print "Contrast:\tHigh\n";
					}
					elsif ($values[13] == 65535)
					{
						print "Contrast:\tLow\n";
					}
					else
					{
						print "Contrast:\tUnknown\n";
					}

					# Field 14: saturation
					if ($values[14] == 0)
					{
						print "Saturation:\tNormal\n";
					}
					elsif ($values[14] == 1)
					{
						print "Saturation:\tHigh\n";
					}
					elsif ($values[14] == 65535)
					{
						print "Saturation:\tLow\n";
					}
					else
					{
						print "Saturation:\tUnknown\n";
					}

					# Field 15: sharpness
					if ($values[15] == 0)
					{
						print "Sharpness:\tNormal\n";
					}
					elsif ($values[15] == 1)
					{
						print "Sharpness:\tHigh\n";
					}
					elsif ($values[15] == 65535)
					{
						print "Sharpness:\tLow\n";
					}
					else
					{
						print "Sharpness:\tUnknown\n";
					}

					# Field 16: ISO
					# Used by G1. On D30 this is 0 and value is in
					# EXIF ISOSpeedRatings
					if ($values[16] == 15)
					{
						print "ISO:\tAuto\n";
					}
					elsif ($values[16] == 16)
					{
						print "ISO:\t50\n";
					}
					elsif ($values[16] == 17)
					{
						print "ISO:\t100\n";
					}
					elsif ($values[16] == 18)
					{
						print "ISO:\t200\n";
					}
					elsif ($values[16] == 19)
					{
						print "ISO:\t400\n";
					}

					# field 17: metering mode
					if ($values[17] == 3)
					{
						print "MeteringMode:\tevaluative\n";
					}
					elsif ($values[17] == 4)
					{
						print "MeteringMode:\tpartial\n";
					}
					elsif ($values[17] == 5)
					{
						print "MeteringMode:\tcentre-weighted\n";
					}

					# field 18: unknown

					# field 19: AF point selected
					if ($values[19] == 0x3000)
					{
						print "AFPoint:\tnone (MF)\n";
					}
					elsif ($values[19] == 0x3001)
					{
						print "AFPoint:\tauto-selected\n";
					}
					elsif ($values[19] == 0x3002)
					{
						print "AFPoint:\tright\n";
					}
					elsif ($values[19] == 0x3003)
					{
						print "AFPoint:\tcentre\n";
					}
					elsif ($values[19] == 0x3004)
					{
						print "AFPoint:\tleft\n";
					}

					# field 20: 'creative' exposure mode
					if ($values[20] == 0)
					{
						# 'subject based' exposure mode in 12th field
						if ($values[11] == 0)
						{
							print "ExposureMode:\tAuto\n";
						}
						elsif ($values[11] == 1)
						{
							print "ExposureMode:\tManual\n";
						}
						elsif ($values[11] == 2)
						{
							print "ExposureMode:\tLandscape\n";
						}
						elsif ($values[11] == 3)
						{
							print "ExposureMode:\tFast shutter\n";
						}
						elsif ($values[11] == 4)
						{
							print "ExposureMode:\tSlow shutter\n";
						}
						elsif ($values[11] == 5)
						{
							print "ExposureMode:\tNight scene\n";
						}
						elsif ($values[11] == 6)
						{
							print "ExposureMode:\tBlack and white\n";
						}
						elsif ($values[11] == 7)
						{
							print "ExposureMode:\tSepia\n";
						}
						elsif ($values[11] == 8)
						{
							print "ExposureMode:\tPortrait\n";
						}
						elsif ($values[11] == 9)
						{
							print "ExposureMode:\tSports\n";
						}
						elsif ($values[11] == 10)
						{
							print "ExposureMode:\tClose-up\n";
						}
						elsif ($values[11] == 11)
						{
							print "ExposureMode:\tPan focus\n";
						}
						else
						{
							print "ExposureMode:\tUnknown\n";
						}
					}
					elsif ($values[20] == 1)
					{
						print "ExposureMode:\tProgram\n";
					}
					elsif ($values[20] == 2)
					{
						print "ExposureMode:\tTv\n";
					}
					elsif ($values[20] == 3)
					{
						print "ExposureMode:\tAv\n";
					}
					elsif ($values[20] == 4)
					{
						print "ExposureMode:\tManual\n";
					}
					elsif ($values[20] == 5)
					{
						print "ExposureMode:\tA-DEP\n";
					}
					else
					{
						print "ExposureMode:\tUnknown\n";
					}

					# fields 21 and 22: unknown

					# field 23: max focal length, 24: min focal length, 25: units per mm
					print "MaxFocalLength:\t", $values[23] / $values[25], " mm\n";
					print "MinFocalLength:\t", $values[24] / $values[25], " mm\n";

					# fields 26-28: unknown

					# field 29: flash details
					print "FlashMode:\tFP sync enabled\n" if ($values[29] & 0x0010);
					print "FlashMode:\tFP sync used\n" if ($values[29] & 0x0800);
					print "FlashMode:\tinternal flash\n" if ($values[29] & 0x2000);
					print "FlashMode:\texternal E-TTL\n" if ($values[29] & 0x4000);

					# field 34 is ImageStabilisation (Pro90IS)
					if ($cameraModel =~ /Pro90/i)
					{
						if ($values[34])
						{
							print "ImageStabilisation:\tOn\n";
						}
						else
						{
							print "ImageStabilisation:\tOff\n";
						}
					}
				}
				elsif ($tag == 4)
				{
					# field 0: length of tag in bytes
					# fields 1-6: unknown

					# field 7: white balance
					if ($values[7] == 0)
					{
						print "WhiteBalance:\tAuto\n";
					}
					elsif ($values[7] == 1)
					{
						print "WhiteBalance:\tDaylight\n";
					}
					elsif ($values[7] == 2)
					{
						print "WhiteBalance:\tCloudy\n";
					}
					elsif ($values[7] == 3)
					{
						print "WhiteBalance:\tTungsten\n";
					}
					elsif ($values[7] == 4)
					{
						print "WhiteBalance:\tFluorescent\n";
					}
					elsif ($values[7] == 5)
					{
						print "WhiteBalance:\tFlash\n";
					}
					elsif ($values[7] == 6)
					{
						print "WhiteBalance:\tCustom\n";
					}
					else
					{
						print "WhiteBalance:\tUnknown\n";
					}

					# field 8: unknown
					# field 9: sequence number if in a continuous burst
					# field 10-13: unknown

					# field 14: AF point used
					if ($values[14] & 0x7)
					{
						print "AFPointsUsed:\t", ($values[14] >> 12) & 0x0f, " - ";
						print " left" if $values[14] & 0x4;
						print " centre" if $values[14] & 0x2;
						print " right" if $values[14] & 0x1;
						print "\n";
					}

					# field 15: flash exposure compensation
					{
						my $value = $values[15];
						$value -= 65536 if ($value > 32768);
						$value = compensationFraction($value / 32);
						print "FlashExposureCompensation:\t$value\n";
					}

					# field 19 is subject distance
					# Appears to be the same as the EXIF tag, use that instead
					print "SubjectDistance:\t$values[19]\n" if !$outputUseful;
				}
				elsif ($tag == 15)
				{
					# Custom functions (EOS D30)
					# Uses info supplied by David Burren, but not tested - I don't have a D30 :(
					for ($i = 1; $i <=$#values; $i++)
					{
						my $func = ($values[$i] >> 8) & 0xff;
						my $value = $values[$i] & 0xff;
						if ($func == 1)
						{
							# Not sure about this
							print "CustomFunction:\t$function Long exposure noise reduction: ";
							if ($value)
							{
								print "On\n";
							}
							else
							{
								print "Off\n";
							}
						}
						elsif ($func == 2)
						{
							print "CustomFunction:\t$function Shutter/AE-lock buttons: \n";
							if ($value == 0)
							{
								print "AF/AE lock\n";
							}
							elsif ($value == 1)
							{
								print "AE lock/AF\n";
							}
							elsif ($value == 2)
							{
								print "AF/AF lock\n";
							}
							elsif ($value == 3)
							{
								print "AE+release/AE+AF\n";
							}
							else
							{
								print "unknown\n";
							}
						}
						elsif ($func == 3)
						{
							print "CustomFunction:\t$function Mirror lockup: ";
							if ($value)
							{
								print "Enable\n";
							}
							else
							{
								print "Disable\n";
							}
						}
						elsif ($func == 4)
						{
							print "CustomFunction:\t$function Tv/Av and exposure level: ";
							if ($value)
							{
								print "1/3 stop\n";
							}
							else
							{
								print "1/2 stop\n";
							}
						}
						elsif ($func == 5)
						{
							print "CustomFunction:\t$function AF assist light: ";
							if ($value)
							{
								print "Off\n";
							}
							else
							{
								print "On (auto)\n";
							}
						}
						elsif ($func == 6)
						{
							print "CustomFunction:\t$function Shutter speed in Av mode: ";
							if ($value)
							{
								print "1/200 (fixed)\n";
							}
							else
							{
								print "auto\n";
							}
						}
						elsif ($func == 7)
						{
							print "CustomFunction:\t$function AEB sequence/auto cancellation: ";
							if ($value == 0)
							{
								print "0, -, + enabled\n";
							}
							elsif ($value == 1)
							{
								print "0, -, + disabled\n";
							}
							elsif ($value == 2)
							{
								print "-, 0, + enabled\n";
							}
							elsif ($value == 3)
							{
								print "-, 0, + disabled\n";
							}
							else
							{
								print "unknown\n";
							}
						}
						elsif ($func == 8)
						{
							print "CustomFunction:\t$function Shutter curtain sync: ";
							if ($value)
							{
								print "2nd curtain sync\n";
							}
							else
							{
								print "1st curtain sync\n";
							}
						}
						elsif ($func == 9)
						{
							print "CustomFunction:\t$function Lens AF stop button fn. switch: ";
							if ($value == 0)
							{
								print "AF stop\n";
							}
							elsif ($value == 1)
							{
								print "operate AF\n";
							}
							elsif ($value == 2)
							{
								print "Lock AE and start timer\n";
							}
							else
							{
								print "unknown\n";
							}
						}
						elsif ($func == 10)
						{
							print "CustomFunction:\t$function Auto reduction of fill flash: ";
							if ($value)
							{
								print "Disable\n";
							}
							else
							{
								print "Enable\n";
							}
						}
						elsif ($func == 11)
						{
							print "CustomFunction:\t$function Menu button return position: ";
							if ($value)
							{
								print "previous\n";
							}
							else
							{
								print "top\n";
							}
						}
						elsif ($func == 12)
						{
							print "CustomFunction:\t$function SET button func when shooting: ";
							if ($value == 0)
							{
								print "not assigned\n";
							}
							elsif ($value == 1)
							{
								print "change quality\n";
							}
							elsif ($value == 2)
							{
								print "change ISO speed\n";
							}
							elsif ($value == 3)
							{
								print "select parameters\n";
							}
							else
							{
								print "unknown\n";
							}
						}
						elsif ($func == 13)
						{
							print "CustomFunction:\t$function Sensor cleaning: ";
							if ($value)
							{
								print "Enable\n";
							}
							else
							{
								print "Disable\n";
							}
						}
						else
						{
							print "CustomFunction:\t$function = $value\n";
						}
					}
				}
			}
			else
			{
				printf("MakerNote: unrecognised TAG: 0x%x, format: $format, components: $components, offset: $offset\n", $tag);
				my $value = readIFDEntry($data, $format, $components, $offset);
				print "value: $value\n";
			}
		}
	}
}

# read 2-byte short, byte aligned according to $intelAlignment
sub readShort
{
	my ($data, $offset) = @_;
	die "readShort: end of string reached" if length($data) < $offset + 2;
	my $ch1 = ord(substr($data, $offset++, 1));
	my $ch2 = ord(substr($data, $offset++, 1));
	if ($intelAlignment)
	{
		return $ch1 + 256 * $ch2;
	}
	return $ch2 + 256 * $ch1;
}

# read 4-byte long, byte aligned according to $intelAlignment
sub readLong
{
	my ($data, $offset) = @_;
	die "readLong: end of string reached" if length($data) < $offset + 4;
	my $ch1 = ord(substr($data, $offset++, 1));
	my $ch2 = ord(substr($data, $offset++, 1));
	my $ch3 = ord(substr($data, $offset++, 1));
	my $ch4 = ord(substr($data, $offset++, 1));
	if ($intelAlignment)
	{
		return (((($ch4 * 256) + $ch3) * 256) + $ch2) * 256 + $ch1;
	}
	return (((($ch1 * 256) + $ch2) * 256) + $ch3) * 256 + $ch4;
}

# read formatted IFD entry
sub readIFDEntry
{
	my ($data, $format, $components, $offset) = @_;
	if ($format == 2)
	{
		# ASCII string
		my $value = substr($data, $offset, $components);
		$value =~ s/\0+$//; # remove trailing NULL chars
		return $value;
	}
	elsif ($format == 3)
	{
		# Unsigned short
		return $offset;
	}
	elsif ($format == 4)
	{
		# Unsigned long
		return readLong($data, $offset);
	}
	elsif ($format == 5)
	{
		# Unsigned rational
		my $numerator = readLong($data, $offset);
		my $denominator = readLong($data, $offset + 4);
#print "$numerator / $denominator\n";
		return $numerator / $denominator;
	}
	elsif ($format == 10)
	{
		# Signed rational
		my $numerator = readLong($data, $offset);
		$numerator -= 2 ** 32 if ($numerator > 2 ** 31);
		my $denominator = readLong($data, $offset + 4);
#print "$numerator / $denominator\n";
		return $numerator / $denominator;
	}
	else
	{
		die "Invalid IFD entry format: $format";
	}
}

sub debug
{
	print "@_\n" if $debug;
}

# convert -6 to +6 to -2 to +2 EV compensation
# value in 1/3 steps
sub compensationFraction
{
	my ($value) = @_;
	return 0 if $value == 0;
	my $result;
	if ($value < 0)
	{
		$result = '-';
		$value = -$value;
	}
	else
	{
		$result = '+';
	}

	# deal in 1/6ths then we can handle 1/2 or 1/3 stop increments
	$value = int(0.5 + $value * 6);
	my $integer = int($value / 6);
	my $sixths = $value % 6;

	# deal with integer part first
	if ($integer)
	{
		$result .= $integer;
		$result .= ' ' if $sixths;
	}

	# now sort out fractional part
	if ($sixths == 2)
	{
		$result .= "1/3";
	}
	elsif ($sixths == 3)
	{
		$result .= "1/2";
	}
	elsif ($sixths == 4)
	{
		$result .= "2/3";
	}
	return $result;
}
